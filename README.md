# Conversão de imagem RGB em imagem Grayscale
Utilizando as bibliotecas: OpenCV, numpy, matplotlib.pyplot. No codigo a imagem **t1.jpg** é lida como colorida e armazenada na variavel ***img***. após isso a imagem é dividida entre os três canais de cores R,G e B por meio do **cv2.split** para que seja possivel fazer a operação que irá gerar a imagem em escala de cinza ponderada. utilizando essa operação R*0.299+G*0.587+B*0.114, cada canal é multiplicado por um peso para diminuir a intencidade de cada cor e após isso são somados parar gerar a imagem em preto e branco que é armazenada na variavel **img_grayscale_pondered**. Está variavel será convertida para uma matriz do numpy para fazer com que os valores de cada pixel estejam dentro da faixa de 0 a 255, para fazer isso o tipo de dado da matriz foi definido para **np.uint8** esses valores garantem que a imagem esteja realmente em uma escala de cinza. Ao final a imagem é exibida por meio do comando **cv2_imshow**

# Transformações
## Negativo
Utilizando as bibliotecas: OpenCV O codigo carrega a imagem **t1.jpg** que pode ser lida como colorida ou em preto e branco,para isso basta mudar o valor atribuido á variavel ***colorida*** para 1 ou 0, a imagem lida é atribuida a variavel ***img.in***. após isso a variavel ***img_in*** passa por uma operação de  subtração de 255 da intensidade em cada pixel (operação de negativo), o resultado é a imagem em negativo que é guardado em na variavel ***img_out***. após a operação duas imagens são exibidas por meio do **img.show**, uma é a imagem original e a outra é a imagem em negativo.
## Contraste e Brilho
Utilizando a biblioteca OpenCV, A imagem **t1.jpg** é lida em escala de cinza e guardada na variavel **img_in**, para poder alterar os valores de contraste e brilho utiliza-se as variaveis ***a*** para mmanipilar o contraste e ***b*** para manipular o brilho da imagem. No codigo os pixels da imagem original são multiplicados por ***a*** para aumentar ou diminuir o contraste e após isso são somados a ***b*** para aumentar o brilho o resultado é guardado na variavel **img.out**. após isso a matriz contida na variavel 'img.out' é convertida para o tipo de dado 8-bit unsigned integer (numeros sem sinal e inteiros de 8 bit), para garantir que os valores dessa matriz estejam na faixa de 0 a 255. Por fim o a imagem original e a manipulada são exibidas por meio da função **img_show**.

# Filtro Espacial (suavização)
utilizando a bilbioteca Open.CV, O codigo lê a imagem **ti.jpg** como colorida e atribui a leitura para a variavel ***img_in***. é criada uma matriz kernel 5x5 onde todos os termos são 1 e o tipo de dado dessa matriz é **float**. A matriz é dividida por 25 para normaliza-la e evitar que a operação mude a intencidade de cada pixel da imagem. Com o kernel já criado utilizou-se a função **cv2.filter2D** para aplicar o filtro kernel na imagem ***img_in***, o resultado dessa aplicação é atribuido a variavel ***img_out_1***, ao final duas imagens são exibidas por meio do **cv2.im_show** uma é a imagem original e a outra é a imagem suavizada.
